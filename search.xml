<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo转换语言，适用任何主题</title>
    <url>/2023/05/20/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要讨论Hexo如何最简单地实现国际化，而且该方法适用性很高，对使用哪种主题我个人认为没有什么要求</p>
<h1 id="理想解决方案"><a href="#理想解决方案" class="headerlink" title="理想解决方案"></a>理想解决方案</h1><p>在主页存在一个按钮，通过单击该按钮可以实现一键切换语言的页面（本博客示例将是中英文）。同时该方法的实现不需要新买一个域名。</p>
<p>值得注意的是，该方法不是直接翻译，所以需要同时维护N份post的博客文件（N是你的语言数量），所以如果你需要更新博客，需要同时更新N份文件。</p>
<p>以下的实现流程将会以中英文作为示例，更多语言参照此教程即可：</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>（1）分割页面文件夹，假设你原来的文件都存放在一个叫做hexo的文件夹中，主要存放的是中文文件。现在新建一个叫做hexo-en的文件夹用于存放英文的文件夹。注意：它们是同级的！</p>
<p>构建好的文件夹应该如下：</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(1).png" alt="文件夹位置展示"></p>
<p>（2）复制除了node_modules外的所有文件从hexo到hexoen，将站点分开</p>
<p>（3）接下来修改两个hexo的 <strong>_config.yml</strong> 文件内容，下图第一个为hexo，第二个为hexo-en：（这一步是修改了hexo的主要语言）</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(2).png" alt="hexo"></p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(3).png" alt="hexo-en"></p>
<p>（4）继续修改 <strong>_config.yml</strong> 的根目录url和root，下图第一个为hexo，第二个为hexo-en：</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(4).png" alt="hexo"></p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(5).png" alt="hexo-en"></p>
<p>（5）修改你自己对应主题的menu的跳转链接，注意这里有个坑——<strong>你可以跳转向自己github.io&#x2F;en的链接，你也可以跳转向自己域名&#x2F;en的链接。我这里跳转github.io不知道为什么失败了，显示404，但是跳转域名thellu.com&#x2F;en成功了。</strong>你们可以按照自己实际情况选择跳转的地址。</p>
<p>另外，注意如果你是中文主页，menu则应该设置English;如果你是英文主页，menu应该设置中文。</p>
<p>下图第一个为hexo，第二个为hexo-en：</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(6).png" alt="hexo"></p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(7).png" alt="hexo-en"></p>
<p>（6）恭喜，现在基本的配置就完成了！现在在 hexoen文件夹执行 <strong>npm install</strong> 安装需要的插件</p>
<p>（7）最后，修改你每次提交文件到github的命令，你需要使用cp每次合并提交文件上去。我这里使用的是绝对路径，因此cd路径的时候方便修改地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /d/Blog/hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; cd /d/Blog/hexoen &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; cd /d/Blog/hexo &amp;&amp; cp -r /d/Blog/hexoen/public/. /d/Blog/hexo/public/en/ &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>（8）恭喜，到现在配置就完成了！你可以看下检查自己的网站是否已经成功页面跳转了。唯一的缺点是点击会跳转到新页面而不是更新原页面。</p>
<h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>正常编写md文件后用上述代码上传的时候，有时会莫名其妙报错：</p>
<blockquote>
<p>err : Error: Spawn Failed</p>
</blockquote>
<p>问题一般出现在.deploy_git文件夹，这是由hexo框架渲染生成的一个Git仓库,*<code>hexo d</code>*命令就是将其push到github上。问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容导致了报错。</p>
<p>总而言之，删除这个文件就好。</p>
<p>然后调用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<p>再执行hexo的clean g d指令即可。</p>
<p>但是要注意，这个报错还有两个原因：</p>
<ul>
<li>我们的提交到github代码采用的是绝对路径，如果你在hexoen打开git bash，那这个.deploy_git文件可能会保存在hexoen文件夹里，这个时候记得把它也删掉。</li>
<li>网络波动，删了.deploy_git等一会它自己就好了</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>项目记录——第一次接触企业需求</title>
    <url>/2023/06/08/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8E%A5%E8%A7%A6%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<h1 id="项目记录——第一次接触企业需求"><a href="#项目记录——第一次接触企业需求" class="headerlink" title="项目记录——第一次接触企业需求"></a>项目记录——第一次接触企业需求</h1><h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>最近接到了自己的第一个需求，为一个已经做好的页面做迁移使得可以做到外部访问并展示的效果。什么意思呢？后文会对这个需求做解释。</p>
<p>总之，作为一个开发新人，不得不说面对企业级的庞大代码，后端前端加起来上百个类的时候是一脸懵的，更别说还需要直接面对一个自己之前没接触过的需求了。当然，产品经理也明白一来让我做很难的需求也不现实，这个需求的实际实现并不算难，很多关键部位的代码已经被其他人完成了，但是对我来说也还是一个巨大的挑战。</p>
<h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>简单的说，这个项目需求要求我把原来放在管理系统中的页面可以通过外部链接进行访问。</p>
<p>前端的页面和功能很多是通过类似Vue-element-admin的方式展示的。我需要把其中一个已经完成的Vue页面——一张BI报表，绕过登录系统做到可以直接通过链接访问的形式（当然并不是完全不需要登录验证了，只是换了一种验证形式），至于完成后会拿来怎么用，现在我不是太清楚，可能会有一些别的APP的超链接指向这里。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>需求是这样的，但是依旧有很多不理解的问题：</p>
<ul>
<li>链接？是什么样的链接去访问的？它应该是什么样子的？</li>
<li>前端应该怎么实现？</li>
<li>后端需要做什么？</li>
<li>其他同事已经做了哪些事情？</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>作为一个新人，需要不断学习，但是当然不能是闷头学习。</p>
<p>通过请教前辈，了解到这个连接迁移功能的实现是在一个Vue页面实现的，也是通过这一节课，我学到了了解项目，破解需求的第一个思路：</p>
<blockquote>
<p><strong>前端代码反推后端</strong></p>
</blockquote>
<p>这里展示一下大概的前端页面构造，出于隐私考虑隐瞒了具体信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	<span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;XXcomponents[index]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>		</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">import</span> ...</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="title class_">XXcomponents</span>:[</span><br><span class="line">                   <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;c&#x27;</span>...</span><br><span class="line">               ],</span><br><span class="line">               <span class="attr">index</span>:<span class="number">0</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">window</span>.<span class="property">myData</span> = <span class="variable language_">this</span></span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">routeData</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span></span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">method</span>()</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">methods</span>:&#123;</span><br><span class="line">           <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;/.../loginByUsername&#x27;</span>,<span class="variable language_">this</span>.<span class="property">routeData</span>.<span class="property">data</span>)</span><br><span class="line">                 .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                   <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">XXcomponents</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">i</span> =&gt;</span> i == <span class="variable language_">this</span>.<span class="property">routeData</span>.<span class="property">name</span> )</span><br><span class="line">                   ...</span><br><span class="line">               &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                   ...</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">components</span>:&#123;</span><br><span class="line">             a,</span><br><span class="line">             b,</span><br><span class="line">             c...</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125; </span><br><span class="line">        </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span>...<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这里的template标签呈现前端内容，可以看到只有一个:is绑定的动态组件，联想一下我们要做的是连接迁移，所以有理由可以<strong>猜想</strong>这里的components可能是根据index确定传入的页面是什么，然后在前端展示。</p>
<p>于是我自然地去看data属性里面的数据，可以看到XXcomponents对应的正好也是components属性里面的组件，这些组件是通过import导入的其他已经写好的Vue页面，这证实了我的猜想。</p>
<p>现在，我们已经知道了前端是怎么通过一个Vue页面实现连接迁移的功能了：</p>
<blockquote>
<p>通过切换index切换列表里面要展示的Vue页面</p>
</blockquote>
<p>那么，后端呢？</p>
<p>我看到这里Vue的生命周期create里面有写this.$route.query，这说明这个Vue页面创建的时候需要接收参数，这里的参数是直接写在网址里面的，this.$route.query的结果被写入了this.routeData，那后面的代码出现了this.routeData.name和this.routeData.data，那有理由相信传入链接里面的参数应该是类似这个样子的，例如：</p>
<blockquote>
<p> localhost:8888&#x2F;index&#x2F;data&#x3D;123&amp;name&#x3D;123</p>
</blockquote>
<p>那传入的数据就是:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>data<span class="punctuation">:</span><span class="number">123</span><span class="punctuation">,</span> name<span class="punctuation">:</span><span class="number">123</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>接收参数的事情往往和后端就有关系了，那它接收什么参数呢？</p>
<p>暂时不知道了，但是后面有个method方法，这个方法内部使用了异步的dispatch方法，向一个叫做loginByUsername的方法发送了参数，发送的值是我们前文提到的链接中的name属性对应的值。</p>
<p>现在，前端访问了后端一个叫做loginByUsername的方法了，并且把其中的name属性对应的值以Json格式传递了过去。</p>
<p>打开后端idea，输入：<strong>ctrl + shift + f</strong>，寻找匹配的loginByUsername方法。</p>
<p>很快我就找到了匹配的方法，一个写在@Controller里面的@PostMapping方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> WebResult <span class="title function_">loginByUsername</span> <span class="params">(<span class="meta">@Requestbody</span> UserNameDTO userNameDTO)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> (userNameDTO.getUserName())</span><br><span class="line">    <span class="comment">// get token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> ...(userName);</span><br><span class="line">    ......    </span><br><span class="line">    <span class="keyword">return</span> WebResult.ok(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserNameDTO</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法接收一个@Requestbody 的UserNameDTO实体类，然后用它获取username，把username通过Service层封装好的方法经过Base64加密后作为认证信息返回给前端。（WebResult是一个封装好的类，用于定制返回值到WSDL的映射）</p>
<p>至此，后端的功能也确认了：</p>
<blockquote>
<p>后端需要前端传入的userName信息，然后通过userName产生一个用于身份验证、网页跳转即连接迁移的token返回给前端。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后，链接的data属性将会被后面的findIndex方法用作确定index，然后根据index匹配对应的vue页面进行展示。</p>
<p>到此，我们可以通过访问如下链接：</p>
<blockquote>
<p>localhost:8888&#x2F;index&#x2F;data&#x3D;study&amp;name&#x3D;James</p>
</blockquote>
<p>匹配到一个属于James的study.vue前端界面，并展示对应的信息。</p>
<p>总的来说，这个需求并不难，其中核心的功能实现，例如dispatch对应的网址，根据Index匹配对应的vue页面，后端的token生成等功能的实现已经被封装了。不过作为第一个需求，对我来说也有一定难度，更重要的是学会了</p>
<ol>
<li><strong>如何在企业项目中理清思路——通过前端代码反推后端代码</strong></li>
<li><strong>重要的ctrl + shift + f</strong></li>
</ol>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>内网项目踩坑记录</title>
    <url>/2023/06/06/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="内网项目踩坑记录"><a href="#内网项目踩坑记录" class="headerlink" title="内网项目踩坑记录"></a>内网项目踩坑记录</h1><p>众所周知，有的项目是完全建立在内网的离线模式的。最近第一次接触这种离线模式的项目，记录一下遇到的问题：</p>
<h2 id="Maven-offline-model"><a href="#Maven-offline-model" class="headerlink" title="Maven offline model"></a>Maven offline model</h2><p>由于内网要求，所以项目是运行在虚拟机上的，开发环境在虚拟机上不能联网，所以所有项目都是需要重新下载下来。在配置pom.xml的时候出现了问题，idea一直报一个奇怪的错误：</p>
<blockquote>
<p>Cannot access maven-default-http-blocker (<a href="http://0.0.0.0/">http://0.0.0.0/</a>) in offline mode</p>
</blockquote>
<p>最开始按照网上指示，开启了maven的offline模式，但是还是不能解决问题，后来发现是Maven的版本问题</p>
<p>这是因为我使用的idea默认的Bundled(Maven3)，这里的maven版本是3.8以上太高了，在高版本的maven的setting.xml文件中有一个镜像：</p>
<p>首先，思考内部类是怎么运行的。我们知道在内部类编译成功后，它会产生一个新的class文件。</p>
<p>该class文件仅仅只保留了对外部类的引用。</p>
<p>举个例子，当外部类传入的参数需要被内部类调用时，直接看起来好像就是被直接调用的： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blockerid&gt;</span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:http:*mirrorOf&gt;</span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.name&gt;</span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/url&gt;</span><br><span class="line">     <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>trueblocked&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个东西是maven默认阻止外部 HTTP 存储库，简单的处理就是把它注释掉。如果用户不主动注释掉maven-default-http-blocker配置，这会导致IDEA在使用捆绑的maven时出现持久性问题。</p>
<p>这个其实有点不方便，设置这个主要原因是使用HTTP协议下载依赖，可能会导致中间人攻击。所以Maven 3.8.1就禁止了所有HTTP协议的Maven仓库。</p>
<p>所以，解决方案主要就是两种：</p>
<ol>
<li>降低版本</li>
<li>当idea加载外部配置文件时会优先加载安装目录下\plugins\maven\lib\maven3\conf文件夹内的settings.xml，注释该文件中maven-default-http-blocker配置</li>
</ol>
<h2 id="idea-SVN导入项目"><a href="#idea-SVN导入项目" class="headerlink" title="idea SVN导入项目"></a>idea SVN导入项目</h2><p>项目是运行于神奇的SVN而不是git上的，当尝试从svn导入项目的时候，类似git，我们从idea File -&gt; new -&gt; project from version control打开界面：</p>
<p><img src="/images/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.png" alt="内网项目踩坑记录"></p>
<p>可以看到上方有一个version control的选项，这里的下拉菜单可以选择subversion（即SVN).</p>
<p>选择之后输入公司SVN项目的url，就会自动生成对应的文件夹，里面有项目代码，测试代码，包这些。但是第一次运行SVN的时候往往会出问题，这里会报错：</p>
<blockquote>
<p>Cannot run program “svn”: CreateProcess error&#x3D;2</p>
</blockquote>
<p>原因是SVN需要使用命令行工具，如果本地没有SVN的命令行工具，则导致出错。</p>
<p>所以重新打开你安装SVN的msi文件，选择modify （点击左边的图片而不是文字），安装command line client tools就OK了。</p>
<p><img src="/images/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95(2).png" alt="内网项目"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机类加载的初始化</title>
    <url>/2023/06/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Java虚拟机类加载的初始化"><a href="#Java虚拟机类加载的初始化" class="headerlink" title="Java虚拟机类加载的初始化"></a>Java虚拟机类加载的初始化</h1><p>我们知道，《Java虚拟机规范》章节5.5 Initialization ^(1)^ 中严格规定了有且只有六种情况必须立即对类进行初始化：</p>
<blockquote>
<ul>
<li>遇到new（实例化对象）、getstatic（读取一个没有被final修饰、没有在编译期把结果放入常量池的类的静态字段）、putstatic（设置一个没有被final修饰、没有在编译期把结果放入常量池的类的静态字段）或者invokestatic（调用一个类的静态方法）这四条字节码指令时，如果类没有进行初始化则需要触发初始化。</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用</li>
<li>父类还没有初始化</li>
<li>虚拟机启动时，用户需要制定一个要执行的主类（main）</li>
<li>当使用java7新加入的动态语言支持时，如果一个MthodHandle实例最后的解析结果是REF_getStatic、REF_putstatic、REF_invokestatic、REF_newInvokeSpecial四种类型的方法句柄</li>
<li>一个接口定义了default修饰的接口方法，同时接口的实现类发生了初始化</li>
</ul>
</blockquote>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用：</p>
<h2 id="子类引用父类"><a href="#子类引用父类" class="headerlink" title="子类引用父类"></a>子类引用父类</h2><p>通过子类引用父类的静态字段不会导致子类初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;System.out.println(<span class="string">&quot;Super&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;System.out.println(<span class="string">&quot;Sub&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeName</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(Sub.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果是什么呢？会先输出“Super”，然后是value的值。</p>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过子类引用父类静态字段，也只有父类会初始化。</p>
<h2 id="数组引用类"><a href="#数组引用类" class="headerlink" title="数组引用类"></a>数组引用类</h2><p>通过数组定义来引用类，不会触发此类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeName</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Sub[] sp = <span class="keyword">new</span> <span class="title class_">Sub</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果是什么呢？</p>
<p>什么也没有。</p>
<p>可见Sub类并没有被初始化。不过这段代码触发了另一个名为“[Lcom.example.demo.Sub”的类的初始化阶段。这玩意是虚拟机自动生成的直接继承自Object的子类，创建动作由字节码指令anewarray（即新建引用数组）触发。</p>
<p>这个类代表的一维数组，用户可直接使用的只有被修饰为Public的length属性和clone方法，当然数组中应用的属性和方法都实现在这个类中。这是因为Java包装了数组元素的访问（在C中是数组指针的移动），这也就是为什么Java检测到数组越界会抛出ArrayIndexOutOfBoundsException异常而不是像C中的非法内存访问。</p>
<p>准确的说，Java的越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload（数组的元素压栈）、xastore（针对数组的操作）字节码指令。</p>
<h2 id="常量池引用"><a href="#常量池引用" class="headerlink" title="常量池引用"></a>常量池引用</h2><p>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;System.out.println(<span class="string">&quot;Super&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLO</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeName</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(Super.HELLO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码运行后也不会输出“Super”。</p>
<p>hello的常量值其实在编译阶段已经被转化成SomeName类对自身常量池的引用了,所以他们俩没什么关系了。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口和类有一点不同。接口其实也有初始化过程，不过接口不能像类一样用static代码块来输出初始化信息，编译器会为接口生成“<clinit>”类构造器，用于初始化接口中定义的成员变量。并且：</p>
<p>接口不要求父接口全部初始化，只有用到了才会初始化。</p>
<hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>(1) Yellin, F. and Lindholm, T., 1996. The java virtual machine specification.</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名内部类形参为什么一定要final</title>
    <url>/2023/06/02/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%BD%A2%E5%8F%82%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81final/</url>
    <content><![CDATA[<h1 id="匿名内部类形参为什么一定要final"><a href="#匿名内部类形参为什么一定要final" class="headerlink" title="匿名内部类形参为什么一定要final?"></a>匿名内部类形参为什么一定要final?</h1><p>最近在写一些匿名内部类的时候会感觉有些难以理解，所以重新复习了一下这部分内容。  发现了一些之前没注意到的点——匿名内部类的形参必须加final前缀（除非匿名内部类没使用它）</p>
<p>那么，怎么理解这个事情的背后原理呢？</p>
<h2 id="内部类运作方式"><a href="#内部类运作方式" class="headerlink" title="内部类运作方式"></a>内部类运作方式</h2><p>首先，思考内部类是怎么运行的。我们知道在内部类编译成功后，它会产生一个新的class文件。</p>
<p>该class文件仅仅只保留了对外部类的引用。</p>
<p>举个例子，当外部类传入的参数需要被内部类调用时，直接看起来好像就是被直接调用的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="keyword">final</span> String name,<span class="keyword">final</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;your name is &quot;</span> + name + <span class="string">&quot; and age is &quot;</span> + age);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是实际上name并不是被内部类直接调用的，实际上java编译后它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass$InnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InnerClass</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.InnerClass$name = name;</span><br><span class="line">        <span class="built_in">this</span>.InnerClass$age = age;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;your name is &quot;</span> + <span class="built_in">this</span>.InnerClass$name + <span class="string">&quot; and age is &quot;</span> + <span class="built_in">this</span>.InnerClass$age );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数！<br>这样理解就很容易得出为什么要用final了，<strong>假设内部类修改这些参数的值，结果原参数的值却没有变化，这就影响了参数的一致性。</strong>从编程人员的角度来看这个参数是一样的，但是假设在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这可能让人感到很困惑，所以为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final的。</p>
<h2 id="匿名内部类运作方式"><a href="#匿名内部类运作方式" class="headerlink" title="匿名内部类运作方式"></a>匿名内部类运作方式</h2><p>OK，匿名内部类相比内部类有什么区别呢——它没有名字。</p>
<p>没名字，所以它是用默认的无参构造器构造，如果需要参数，那么就给他带参数的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(); </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.getInner(<span class="string">&quot;Inner&quot;</span>); </span><br><span class="line">        System.out.println(inner.getName()); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">(<span class="keyword">final</span> String name)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(name) &#123; </span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">nameStr</span> <span class="operator">=</span> name; </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> nameStr; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">    Inner(String name) &#123; </span><br><span class="line">        System.out.println(name); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看，这里getInner方法的参数加了final，理由和之前内部类部分加final的理由是一样的。如果内部类的改变不能影响到外部，那就干脆别动它！</p>
<h2 id="有时候也可以不加final"><a href="#有时候也可以不加final" class="headerlink" title="有时候也可以不加final"></a>有时候也可以不加final</h2><p>什么时候可以不加final呢？如果内部类没有使用它就可以不加final了，这很好理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(); </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.getInner(<span class="number">1</span>); </span><br><span class="line">        System.out.println(inner.f()); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Inner <span class="title function_">getInner</span><span class="params">(<span class="type">int</span> i)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(i) &#123; </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">    Inner(<span class="type">int</span> i) &#123; </span><br><span class="line">        System.out.println(i); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>构造器内部初始化实际过程</title>
    <url>/2023/05/18/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h2><p>类的初始化遵循的顺序很多人都知道是这样：<br>（1）调用基类构造器，不断重复这个过程直到最底层<br>（2）再按照声明的顺序调用成员的初始化方法<br>（3）调用类构造器的主体  </p>
<h2 id="类初始化的实际过程"><a href="#类初始化的实际过程" class="headerlink" title="类初始化的实际过程"></a>类初始化的实际过程</h2><p>但是，考虑这样一个例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Animal.walk()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Animal()&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Animal() before walk()&quot;</span>);</span><br><span class="line">		walk();</span><br><span class="line">		System.out.println(<span class="string">&quot;Animal() after walk()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat.walk(), step = &quot;</span> + step);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Cat(<span class="type">int</span> step)&#123;</span><br><span class="line">		<span class="built_in">this</span>.step = step;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat.Cat(), step = &quot;</span> + step);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">500</span>);</span><br><span class="line">	</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Animal类的walk方法被设计为在Cat类中被重写，但是Animal的构造器会调用这个walk方法，这导致了对Cat.walk()的调用。<br>上述代码的生成结果是：</p>
<blockquote>
<p>Animal() before walk()<br>Cat.walk(), step &#x3D; 0<br>Animal() after walk()<br>Cat.Cat(), step &#x3D; 500</p>
</blockquote>
<p>我们会发现当Animal的构造器调用walk()方法的时候，step不是默认的初始值100，而是0。<br>因此前面讲的类初始化的顺序并不完整，实际上类的初始化顺序应该是这样的：<br>（1）<strong>在所有事情发生之前先分配空间，将分配给对象的存储空间初始化成二进制的零（或者某些特殊数据类型中与零等价的值）</strong><br>（2）如前所述的调用基类构造器，这个时候在调用cat构造器之前就要调用walk方法，因此此时的step值是0<br>（3）按照声明的顺序调用成员的初始化方法<br>（4）调用类构造器的主体<br>当然，这种错误并不容易发现，因此推荐大家如果可以的话，构造器中尽可能避免调用其他方法，在构造器内唯一能够安全调用的那些方法是基类的final方法（因为他们不会被重写，也就不会有上述的问题）。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
