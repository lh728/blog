<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo转换语言，适用任何主题</title>
    <url>/2023/05/20/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要讨论Hexo如何最简单地实现国际化，而且该方法适用性很高，对使用哪种主题我个人认为没有什么要求</p>
<h1 id="理想解决方案"><a href="#理想解决方案" class="headerlink" title="理想解决方案"></a>理想解决方案</h1><p>在主页存在一个按钮，通过单击该按钮可以实现一键切换语言的页面（本博客示例将是中英文）。同时该方法的实现不需要新买一个域名。</p>
<p>值得注意的是，该方法不是直接翻译，所以需要同时维护N份post的博客文件（N是你的语言数量），所以如果你需要更新博客，需要同时更新N份文件。</p>
<p>以下的实现流程将会以中英文作为示例，更多语言参照此教程即可：</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>（1）分割页面文件夹，假设你原来的文件都存放在一个叫做hexo的文件夹中，主要存放的是中文文件。现在新建一个叫做hexo-en的文件夹用于存放英文的文件夹。注意：它们是同级的！</p>
<p>构建好的文件夹应该如下：</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(1).png" alt="文件夹位置展示"></p>
<p>（2）复制除了node_modules外的所有文件从hexo到hexoen，将站点分开</p>
<p>（3）接下来修改两个hexo的 <strong>_config.yml</strong> 文件内容，下图第一个为hexo，第二个为hexo-en：（这一步是修改了hexo的主要语言）</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(2).png" alt="hexo"></p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(3).png" alt="hexo-en"></p>
<p>（4）继续修改 <strong>_config.yml</strong> 的根目录url和root，下图第一个为hexo，第二个为hexo-en：</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(4).png" alt="hexo"></p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(5).png" alt="hexo-en"></p>
<p>（5）修改你自己对应主题的menu的跳转链接，注意这里有个坑——<strong>你可以跳转向自己github.io&#x2F;en的链接，你也可以跳转向自己域名&#x2F;en的链接。我这里跳转github.io不知道为什么失败了，显示404，但是跳转域名thellu.com&#x2F;en成功了。</strong>你们可以按照自己实际情况选择跳转的地址。</p>
<p>另外，注意如果你是中文主页，menu则应该设置English;如果你是英文主页，menu应该设置中文。</p>
<p>下图第一个为hexo，第二个为hexo-en：</p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(6).png" alt="hexo"></p>
<p><img src="/images/Hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98/hexo%E8%BD%AC%E6%8D%A2%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%BB%E4%BD%95%E4%B8%BB%E9%A2%98(7).png" alt="hexo-en"></p>
<p>（6）恭喜，现在基本的配置就完成了！现在在 hexoen文件夹执行 <strong>npm install</strong> 安装需要的插件</p>
<p>（7）最后，修改你每次提交文件到github的命令，你需要使用cp每次合并提交文件上去。我这里使用的是绝对路径，因此cd路径的时候方便修改地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /d/Blog/hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; cd /d/Blog/hexoen &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; cd /d/Blog/hexo &amp;&amp; cp -r /d/Blog/hexoen/public/. /d/Blog/hexo/public/en/ &amp;&amp; hexo d<br></code></pre></td></tr></table></figure>

<p>（8）恭喜，到现在配置就完成了！你可以看下检查自己的网站是否已经成功页面跳转了。唯一的缺点是点击会跳转到新页面而不是更新原页面。</p>
<h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>正常编写md文件后用上述代码上传的时候，有时会莫名其妙报错：</p>
<blockquote>
<p>err : Error: Spawn Failed</p>
</blockquote>
<p>问题一般出现在.deploy_git文件夹，这是由hexo框架渲染生成的一个Git仓库,*<code>hexo d</code>*命令就是将其push到github上。问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容导致了报错。</p>
<p>总而言之，删除这个文件就好。</p>
<p>然后调用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hexo">git config --global core.autocrlf false<br></code></pre></td></tr></table></figure>

<p>再执行hexo的clean g d指令即可。</p>
<p>但是要注意，这个报错还有两个原因：</p>
<ul>
<li>我们的提交到github代码采用的是绝对路径，如果你在hexoen打开git bash，那这个.deploy_git文件可能会保存在hexoen文件夹里，这个时候记得把它也删掉。</li>
<li>网络波动，删了.deploy_git等一会它自己就好了</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机类加载的初始化</title>
    <url>/2023/06/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>我们知道，《Java虚拟机规范》章节5.5 Initialization ^(1)^ 中严格规定了有且只有六种情况必须立即对类进行初始化：</p>
<blockquote>
<ul>
<li>遇到new（实例化对象）、getstatic（读取一个没有被final修饰、没有在编译期把结果放入常量池的类的静态字段）、putstatic（设置一个没有被final修饰、没有在编译期把结果放入常量池的类的静态字段）或者invokestatic（调用一个类的静态方法）这四条字节码指令时，如果类没有进行初始化则需要触发初始化。</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用</li>
<li>父类还没有初始化</li>
<li>虚拟机启动时，用户需要制定一个要执行的主类（main）</li>
<li>当使用java7新加入的动态语言支持时，如果一个MthodHandle实例最后的解析结果是REF_getStatic、REF_putstatic、REF_invokestatic、REF_newInvokeSpecial四种类型的方法句柄</li>
<li>一个接口定义了default修饰的接口方法，同时接口的实现类发生了初始化</li>
</ul>
</blockquote>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用：</p>
<h2 id="子类引用父类"><a href="#子类引用父类" class="headerlink" title="子类引用父类"></a>子类引用父类</h2><p>通过子类引用父类的静态字段不会导致子类初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.example.demo;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Super</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;System.out.println(<span class="hljs-string">&quot;Super&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Super</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;System.out.println(<span class="hljs-string">&quot;Sub&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeName</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(Sub.value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>结果是什么呢？会先输出“Super”，然后是value的值。</p>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过子类引用父类静态字段，也只有父类会初始化。</p>
<h2 id="数组引用类"><a href="#数组引用类" class="headerlink" title="数组引用类"></a>数组引用类</h2><p>通过数组定义来引用类，不会触发此类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeName</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Sub[] sp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>结果是什么呢？</p>
<p>什么也没有。</p>
<p>可见Sub类并没有被初始化。不过这段代码触发了另一个名为“[Lcom.example.demo.Sub”的类的初始化阶段。这玩意是虚拟机自动生成的直接继承自Object的子类，创建动作由字节码指令anewarray（即新建引用数组）触发。</p>
<p>这个类代表的一维数组，用户可直接使用的只有被修饰为Public的length属性和clone方法，当然数组中应用的属性和方法都实现在这个类中。这是因为Java包装了数组元素的访问（在C中是数组指针的移动），这也就是为什么Java检测到数组越界会抛出ArrayIndexOutOfBoundsException异常而不是像C中的非法内存访问。</p>
<p>准确的说，Java的越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload（数组的元素压栈）、xastore（针对数组的操作）字节码指令。</p>
<h2 id="常量池引用"><a href="#常量池引用" class="headerlink" title="常量池引用"></a>常量池引用</h2><p>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Super</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;System.out.println(<span class="hljs-string">&quot;Super&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HELLO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeName</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(Super.HELLO);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的代码运行后也不会输出“Super”。</p>
<p>hello的常量值其实在编译阶段已经被转化成SomeName类对自身常量池的引用了,所以他们俩没什么关系了。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口和类有一点不同。接口其实也有初始化过程，不过接口不能像类一样用static代码块来输出初始化信息，编译器会为接口生成“<clinit>”类构造器，用于初始化接口中定义的成员变量。并且：</p>
<p>接口不要求父接口全部初始化，只有用到了才会初始化。</p>
<hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>(1) Yellin, F. and Lindholm, T., 1996. The java virtual machine specification.</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名内部类形参为什么一定要final</title>
    <url>/2023/06/02/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%BD%A2%E5%8F%82%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81final/</url>
    <content><![CDATA[<p>最近在写一些匿名内部类的时候会感觉有些难以理解，所以重新复习了一下这部分内容。  发现了一些之前没注意到的点——匿名内部类的形参必须加final前缀（除非匿名内部类没使用它）</p>
<p>那么，怎么理解这个事情的背后原理呢？</p>
<h2 id="内部类运作方式"><a href="#内部类运作方式" class="headerlink" title="内部类运作方式"></a>内部类运作方式</h2><p>首先，思考内部类是怎么运行的。我们知道在内部类编译成功后，它会产生一个新的class文件。</p>
<p>该class文件仅仅只保留了对外部类的引用。</p>
<p>举个例子，当外部类传入的参数需要被内部类调用时，直接看起来好像就是被直接调用的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name,<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;your name is &quot;</span> + name + <span class="hljs-string">&quot; and age is &quot;</span> + age);<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">InnerClass</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>();<br>        in.show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>但是实际上name并不是被内部类直接调用的，实际上java编译后它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass$InnerClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InnerClass</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.InnerClass$name = name;<br>        <span class="hljs-built_in">this</span>.InnerClass$age = age;<br>    &#125;  <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;your name is &quot;</span> + <span class="hljs-built_in">this</span>.InnerClass$name + <span class="hljs-string">&quot; and age is &quot;</span> + <span class="hljs-built_in">this</span>.InnerClass$age );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数！<br>这样理解就很容易得出为什么要用final了，<strong>假设内部类修改这些参数的值，结果原参数的值却没有变化，这就影响了参数的一致性。</strong>从编程人员的角度来看这个参数是一样的，但是假设在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这可能让人感到很困惑，所以为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final的。</p>
<h2 id="匿名内部类运作方式"><a href="#匿名内部类运作方式" class="headerlink" title="匿名内部类运作方式"></a>匿名内部类运作方式</h2><p>OK，匿名内部类相比内部类有什么区别呢——它没有名字。</p>
<p>没名字，所以它是用默认的无参构造器构造，如果需要参数，那么就给他带参数的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(); <br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.getInner(<span class="hljs-string">&quot;Inner&quot;</span>); <br>        System.out.println(inner.getName()); <br>    &#125; <br> <br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span> &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(name) &#123; <br>            <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">nameStr</span> <span class="hljs-operator">=</span> name; <br> <br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123; <br>                <span class="hljs-keyword">return</span> nameStr; <br>            &#125; <br>        &#125;; <br>    &#125; <br>&#125; <br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <br>    Inner(String name) &#123; <br>        System.out.println(name); <br>    &#125; <br> <br>    <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>; <br>&#125; <br><br></code></pre></td></tr></table></figure>

<p>看，这里getInner方法的参数加了final，理由和之前内部类部分加final的理由是一样的。如果内部类的改变不能影响到外部，那就干脆别动它！</p>
<h2 id="有时候也可以不加final"><a href="#有时候也可以不加final" class="headerlink" title="有时候也可以不加final"></a>有时候也可以不加final</h2><p>什么时候可以不加final呢？如果内部类没有使用它就可以不加final了，这很好理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(); <br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.getInner(<span class="hljs-number">1</span>); <br>        System.out.println(inner.f()); <br>    &#125; <br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(i) &#123; <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;f()&quot;</span>);<br>            &#125;<br>        &#125;; <br>    &#125; <br>&#125; <br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <br>    Inner(<span class="hljs-type">int</span> i) &#123; <br>        System.out.println(i); <br>    &#125; <br> <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>; <br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内网项目踩坑记录</title>
    <url>/2023/06/06/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>众所周知，有的项目是完全建立在内网的离线模式的。最近第一次接触这种离线模式的项目，记录一下遇到的问题：</p>
<h2 id="Maven-offline-model"><a href="#Maven-offline-model" class="headerlink" title="Maven offline model"></a>Maven offline model</h2><p>由于内网要求，所以项目是运行在虚拟机上的，开发环境在虚拟机上不能联网，所以所有项目都是需要重新下载下来。在配置pom.xml的时候出现了问题，idea一直报一个奇怪的错误：</p>
<blockquote>
<p>Cannot access maven-default-http-blocker (<a href="http://0.0.0.0/">http://0.0.0.0/</a>) in offline mode</p>
</blockquote>
<p>最开始按照网上指示，开启了maven的offline模式，但是还是不能解决问题，后来发现是Maven的版本问题</p>
<p>这是因为我使用的idea默认的Bundled(Maven3)，这里的maven版本是3.8以上太高了，在高版本的maven的setting.xml文件中有一个镜像：</p>
<p>首先，思考内部类是怎么运行的。我们知道在内部类编译成功后，它会产生一个新的class文件。</p>
<p>该class文件仅仅只保留了对外部类的引用。</p>
<p>举个例子，当外部类传入的参数需要被内部类调用时，直接看起来好像就是被直接调用的： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-default-http-blockerid&gt;<br>     <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>external:http:*mirrorOf&gt;<br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.name&gt;<br>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://0.0.0.0/url&gt;<br>     <span class="hljs-tag">&lt;<span class="hljs-name">blocked</span>&gt;</span>trueblocked&gt;<br>   <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这个东西是maven默认阻止外部 HTTP 存储库，简单的处理就是把它注释掉。如果用户不主动注释掉maven-default-http-blocker配置，这会导致IDEA在使用捆绑的maven时出现持久性问题。</p>
<p>这个其实有点不方便，设置这个主要原因是使用HTTP协议下载依赖，可能会导致中间人攻击。所以Maven 3.8.1就禁止了所有HTTP协议的Maven仓库。</p>
<p>所以，解决方案主要就是两种：</p>
<ol>
<li>降低版本</li>
<li>当idea加载外部配置文件时会优先加载安装目录下\plugins\maven\lib\maven3\conf文件夹内的settings.xml，注释该文件中maven-default-http-blocker配置</li>
</ol>
<h2 id="idea-SVN导入项目"><a href="#idea-SVN导入项目" class="headerlink" title="idea SVN导入项目"></a>idea SVN导入项目</h2><p>项目是运行于神奇的SVN而不是git上的，当尝试从svn导入项目的时候，类似git，我们从idea File -&gt; new -&gt; project from version control打开界面：</p>
<p><img src="/images/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.png" alt="内网项目踩坑记录"></p>
<p>可以看到上方有一个version control的选项，这里的下拉菜单可以选择subversion（即SVN).</p>
<p>选择之后输入公司SVN项目的url，就会自动生成对应的文件夹，里面有项目代码，测试代码，包这些。但是第一次运行SVN的时候往往会出问题，这里会报错：</p>
<blockquote>
<p>Cannot run program “svn”: CreateProcess error&#x3D;2</p>
</blockquote>
<p>原因是SVN需要使用命令行工具，如果本地没有SVN的命令行工具，则导致出错。</p>
<p>所以重新打开你安装SVN的msi文件，选择modify （点击左边的图片而不是文字），安装command line client tools就OK了。</p>
<p><img src="/images/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95(2).png" alt="内网项目"></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何调试springboot定时调度任务</title>
    <url>/2023/06/27/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95springboot%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>最近在做企业开发的时候，有个需求需要我对发送邮件的定时调度任务做调整和优化。</p>
<h2 id="Scheduled-定时调度任务"><a href="#Scheduled-定时调度任务" class="headerlink" title="@Scheduled 定时调度任务"></a>@Scheduled 定时调度任务</h2><p>已经完成的发送邮件定时调度任务大概长这样：</p>
<p>首先，思考内部类是怎么运行的。我们知道在内部类编译成功后，它会产生一个新的class文件。</p>
<p>该class文件仅仅只保留了对外部类的引用。</p>
<p>举个例子，当外部类传入的参数需要被内部类调用时，直接看起来好像就是被直接调用的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailScheduled</span>&#123;<br>    <br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 0 23 * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">emailSend</span><span class="hljs-params">()</span>&#123;<br>        ...       <br>        <br>    &#125;        <br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>优化调整的困难点在于debug麻烦：</p>
<ul>
<li>目前的开发环境的代码并没有设置统一接口来通过前端调试后端定时任务</li>
<li>如果通过修改cron来调试，需要重启项目，更重要的是会发很多骚扰邮件出去</li>
<li>还有一个思路是在测试代码里面调用方法，但是也很麻烦</li>
</ul>
<p>实际上还有一个比较简洁的思路，重写*<code>InitialzingBean</code><em>类的</em><code>afterPropertiesSet</code>*方法。</p>
<p>spring初始化bean的时候，如果bean实现了*<code>InitializingBean</code><em>接口，会自动调用</em><code>afterPropertiesSet</code>*方法，所以可以想到，通过这样的方式，就可以通过重启打断点进行调试了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailScheduled</span>&#123;<br>    <br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 0 23 * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">emailSend</span><span class="hljs-params">()</span>&#123;<br>        ...             <br>    &#125; <br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        emailSend();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是很简单？当然，这可能不是最优解，但是如果只在项目中短暂使用，也是问题不大的。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>项目记录——故障排查</title>
    <url>/2023/06/17/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>这里将会记录一些我在企业开发中的遇到的一些长见识的Bug，以及针对别人代码的故障排查</p>
<h2 id="BatchUpdateException-ORA-12899"><a href="#BatchUpdateException-ORA-12899" class="headerlink" title="BatchUpdateException: ORA-12899"></a>BatchUpdateException: ORA-12899</h2><p>Oracle SQL表设计问题 </p>
<h3 id="Bug描述"><a href="#Bug描述" class="headerlink" title="Bug描述"></a>Bug描述</h3><p>产品经理让我排查一下不知道什么环境下（没问是开发、测试还是正式环境）出现的一个Bug，前端上传excel更新数据失败，提示“数据库异常，请联系管理员”。</p>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>很明显，这通常都是后端报错了，所以我按照流程复现了下该报错，然后直接看idea结果，idea报错：</p>
<blockquote>
<p>Exception in thread “main” java.sql.BatchUpdateException: ORA-12899: value too large for column “xx” (actual: 208, maximum: 200)</p>
</blockquote>
<p>这样的报错根据字面意思，似乎是数据超了sql某个字段的字节限制，那么通过我们在 <a href="https://thellu.com/2023/06/08/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82/">项目记录——企业需求</a> 中的连接迁移提到的前端代码反推后端代码的方法，找到对应的后端代码，再找到对应的实体类，看它链接的是哪个数据表，这有助于我们在公司庞大的数据库中直接定位问题表。</p>
<p>定位到问题表table之后，在Navicat点击“设计表”，我可以直接看到每个字段的字节限制，再对应报错的excel文件里面的内容，我可以很简单的找到对应的限制了200个字节的出问题的列。但是奇怪的是，如果一个中文编码占据2个字节，我个人感觉这个excel文件中这个列的数据的字节数并没有达到208这个标准。</p>
<p>查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> userenv(<span class="hljs-string">&#x27;language&#x27;</span>) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure>

<p>结果是 <em><code>AMERICAN_AMERICA.AL32UTF8</code></em></p>
<p>这说明我们Oracle数据库采用的是 <em><code>AMERICAN_AMERICA.AL32UTF8</code></em> 作为字符编码集，这个UTF-8编码集一个中文占据三个字节，为了验证我们的猜想，查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> lengthb(<span class="hljs-string">&#x27;xx&#x27;</span>) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure>

<p>xx就是超过字节限制的数据内容，得到208个字节的答案，这证明我们的猜想没错。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>更换oracle sql中字符编码集为 *<code>SIMPLIFIED CHINESE_CHINA.AL32UTF8</code>*，这样一个中文只占据两个字节。但是显然该方法可能影响到其他表</li>
<li>要求上传excel的数据列对应内容不要太多</li>
<li>针对该字段的字节上限进行扩容</li>
</ul>
<hr>
<h2 id="Json默认解析方式"><a href="#Json默认解析方式" class="headerlink" title="Json默认解析方式"></a>Json默认解析方式</h2><h3 id="Bug描述-1"><a href="#Bug描述-1" class="headerlink" title="Bug描述"></a>Bug描述</h3><p>一个很正常的操作：我在后端调用方法，向前端返回一个List的结果集。我们知道这个结果集在前端是用很多个json数据放在一个List里面的。</p>
<p>我将要返回的数据有这几个列：</p>
<ul>
<li>DESCR - 部门名</li>
<li>userId - ID</li>
<li>name - 姓名</li>
<li>jobType - 工作类型</li>
</ul>
<p>其中 userId,name,jobType在前端展示都是正常的，获取到了数据，但是DESCR这个列没有数据：</p>
<table>
<thead>
<tr>
<th align="center">DESCR</th>
<th align="center">userId</th>
<th align="center">name</th>
<th align="center">jobType</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">C</td>
</tr>
</tbody></table>
<p>看了下后端，打断点发现数据都是正常传过来的，DESCR这个列是有值的，但是不知道为什么在前端不显示</p>
<h3 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h3><p>在前端打断点调试，发现传过来的Json数据长这个样子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>dESCR<span class="hljs-punctuation">:</span>...<span class="hljs-punctuation">,</span>userId<span class="hljs-punctuation">:</span>&#x27;<span class="hljs-number">1</span>&#x27;<span class="hljs-punctuation">,</span>name<span class="hljs-punctuation">:</span>&#x27;a&#x27;<span class="hljs-punctuation">,</span>jobType<span class="hljs-punctuation">:</span>&#x27;A&#x27;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span>dESCR<span class="hljs-punctuation">:</span>...<span class="hljs-punctuation">,</span>userId<span class="hljs-punctuation">:</span>&#x27;<span class="hljs-number">2</span>&#x27;<span class="hljs-punctuation">,</span>name<span class="hljs-punctuation">:</span>&#x27;b&#x27;<span class="hljs-punctuation">,</span>jobType<span class="hljs-punctuation">:</span>&#x27;B&#x27;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>...<br></code></pre></td></tr></table></figure>

<p>这就奇怪了，为啥DESCR这个列的首字母小写了呢？</p>
<p>后来发现，不只是DESCR这个列首字母小写了，事实上每个首字母大写的列的首字母都会被小写，在这里因为它们在这里本来就是小写的所以看不出来。</p>
<p>之所以会这样，探讨其背后原理是因为所有 JSON 的实现都离不开HttpMessageConverter，它是一个消息转换工具，主要实现两方面的功能：</p>
<ul>
<li>将服务端返回的对象序列化成 JSON 字符串</li>
<li>将前端传来的 JSON 字符串反序列化成 Java 对象</li>
</ul>
<p>在SpringBoot生成的依赖包中已经自动为我们导入了相关依赖。SpringMVC 自动配置了 Jackson 和 Gson 的 HttpMessageConverter。</p>
<p>我们公司项目默认使用的Jackson解析Json代码，jackson在序列化过程中会将大写开头的字段自动转成小写开头。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>给需要保留大小写的不变的属性增加*<code>@JsonFormat</code><em>或者</em><code>@JsonProperty</code>*注解</li>
<li>给类加上 <em><code>@JsonAutoDetect(getterVisibility=JsonAutoDetect.Visibility.NONE)</code></em> 注解</li>
</ul>
<hr>
<h2 id="EsayPoi解析Excel图片空指针"><a href="#EsayPoi解析Excel图片空指针" class="headerlink" title="EsayPoi解析Excel图片空指针"></a>EsayPoi解析Excel图片空指针</h2><h3 id="Bug描述-2"><a href="#Bug描述-2" class="headerlink" title="Bug描述"></a>Bug描述</h3><p>一个很有趣的Bug，我在这里被困扰了一天的时间。</p>
<p>现在有两个几乎一模一样的Excel文件，当我进行导入并解析的时候，一个Excel文件会报空指针，一个文件会正常解析并且导入。</p>
<p>这里的业务逻辑是：</p>
<ul>
<li>业务方先下载Excel模板</li>
<li>业务方根据模板输入自己想要导入的信息，其中有一列是图片信息</li>
<li>图片信息是业务方自己粘贴进Excel的</li>
<li>最后业务方点击导入，把Excel解析，把其中的信息导入数据库</li>
</ul>
<p>这个Bug就是业务方在这个流程中遇到的，业务方有两个几乎一模一样的Excel文件，它们的文本信息是完全一样的，唯一的区别就是图片不一样。</p>
<p>而且，就算把可以正常解析导入的Excel文件中的图片粘贴到出问题的Excel文件，也还是会报空指针异常，很奇怪。</p>
<h3 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h3><p>一开始我以为是图片可能覆盖了其他单元格，所以尝试拉伸了一下图片，发现没有作用。</p>
<p>然后仔细研究后端代码，发现这一块是调用的EasyPoi API的 *<code>ExcelImportUtil</code><em>类的</em><code>importExcelMore</code>*方法进行解析的。于是我继续下钻，发现更准确的说，是在调用EasyPoi API的 *<code>PoiPublicUtil</code>*类的 <em><code>getSheetPictures07</code></em> 方法时出现的问题。</p>
<p>更准确的说，是在执行这个放里面如下所示的代码的时候报的错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">...<br>	pic.getPreferredSize()<br>...<br></code></pre></td></tr></table></figure>

<p>打断点，这里需要一个anchor的cell1属性和cell2属性。</p>
<p>然后这里的cell2属性是空，于是报了空指针。</p>
<p>知道错误的起源了，现在回头去找为什么cell2属性是null呢？这个属性是在哪里构造的呢？</p>
<p>经过漫长的寻找，最后发现是在Poi API的*<code>XSSFDrawing</code>*类里面的 <em><code>getAchorFromParent</code></em> 方法里面构造的。</p>
<p>该方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> XSSFAnchor <span class="hljs-title function_">getAnchorFromParent</span><span class="hljs-params">(XmlObject obj)</span> &#123;<br>  <span class="hljs-type">XSSFAnchor</span> <span class="hljs-variable">anchor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">XmlObject</span> <span class="hljs-variable">parentXbean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">XmlCursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> obj.newCursor();<br>  <span class="hljs-keyword">if</span> (cursor.toParent()) &#123;<br>    parentXbean = cursor.getObject();<br>  &#125;<br>  cursor.dispose();<br>  <span class="hljs-keyword">if</span> (parentXbean != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (parentXbean <span class="hljs-keyword">instanceof</span> CTTwoCellAnchor) &#123;<br>      <span class="hljs-type">CTTwoCellAnchor</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> (CTTwoCellAnchor) parentXbean;<br>      anchor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFClientAnchor</span>(ct.getFrom(), ct.getTo());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentXbean <span class="hljs-keyword">instanceof</span> CTOneCellAnchor) &#123;<br>      <span class="hljs-type">CTOneCellAnchor</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> (CTOneCellAnchor) parentXbean;<br>      anchor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFClientAnchor</span>(getSheet(), ct.getFrom(), ct.getExt());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentXbean <span class="hljs-keyword">instanceof</span> CTAbsoluteAnchor) &#123;<br>      <span class="hljs-type">CTAbsoluteAnchor</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> (CTAbsoluteAnchor) parentXbean;<br>      anchor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFClientAnchor</span>(getSheet(), ct.getPos(), ct.getExt());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> anchor;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>不用完全理解代码，只需要看中间这里，<code>parentXbean</code> 将会在这里创造出anchor和它的cell2属性。</p>
<p>当我们使用断点调试，会发现，如果导入有问题的Excel，会走向这个判断：*<code>parentXbean instanceof CTOneCellAnchor</code>*</p>
<p>而正常的Excel会走向这个判断：*<code>parentXbean instanceof CTTwoCellAnchor</code>*</p>
<p>那么，问题就在CTTwoCellAnchor 和 CTOneCellAnchor上面了。</p>
<p>这两个类是什么呢？显然是和图片相关的东西——在这里感谢Greg Woolsey 的解释一下子点醒了我。参考：</p>
<blockquote>
<p><a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=61203">https://bz.apache.org/bugzilla/show_bug.cgi?id=61203</a></p>
</blockquote>
<p>所以，<strong>CTTwoCellAnchor是指图片的大小和位置随着单元格而变</strong>；<strong>CTOneCellAnchor是指大小固定，位置随着单元格而变</strong></p>
<p>那么，这对应的就是Excel里面的图片属性：</p>
<p><img src="/images/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5(1).png" alt="项目记录"></p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>至此，问题就解决了，只需要修改Excel里面的图片属性即可。至此问题就解决了，至于更底层的原因，由于项目排期的紧张没有时间深入钻研，欢迎了解的朋友评论区留言</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Vue</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>项目记录——企业需求</title>
    <url>/2023/06/08/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<p>这里将会记录一些我在企业开发中的一些项目需求</p>
<hr>
<h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><hr>
<p>最近接到了自己的第一个需求，为一个已经做好的页面做迁移使得可以做到外部访问并展示的效果。什么意思呢？后文会对这个需求做解释。</p>
<p>总之，作为一个开发新人，不得不说面对企业级的庞大代码，后端前端加起来上百个类的时候是一脸懵的，更别说还需要直接面对一个自己之前没接触过的需求了。当然，产品经理也明白一来让我做很难的需求也不现实，这个需求的实际实现并不算难，很多关键部位的代码已经被其他人完成了，但是对我来说也还是一个巨大的挑战。</p>
<h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>简单的说，这个项目需求要求我把原来放在管理系统中的页面可以通过外部链接进行访问。</p>
<p>前端的页面和功能很多是通过类似Vue-element-admin的方式展示的。我需要把其中一个已经完成的Vue页面——一张BI报表，绕过登录系统做到可以直接通过链接访问的形式（当然并不是完全不需要登录验证了，只是换了一种验证形式），至于完成后会拿来怎么用，现在我不是太清楚，可能会有一些别的APP的超链接指向这里。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>需求是这样的，但是依旧有很多不理解的问题：</p>
<ul>
<li>链接？是什么样的链接去访问的？它应该是什么样子的？</li>
<li>前端应该怎么实现？</li>
<li>后端需要做什么？</li>
<li>其他同事已经做了哪些事情？</li>
</ul>
<h3 id="思路与实现"><a href="#思路与实现" class="headerlink" title="思路与实现"></a>思路与实现</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>作为一个新人，需要不断学习，但是当然不能是闷头学习。</p>
<p>通过请教前辈，了解到这个连接迁移功能的实现是在一个Vue页面实现的，也是通过这一节课，我学到了了解项目，破解需求的第一个思路：</p>
<blockquote>
<p><strong>前端代码反推后端</strong></p>
</blockquote>
<p>这里展示一下大概的前端页面构造，出于隐私考虑隐瞒了具体信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>	<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    	<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;XXcomponents[index]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>		<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>   <span class="hljs-keyword">import</span> ...<br>   <br>   <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>       <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">return</span> &#123;<br>               <span class="hljs-title class_">XXcomponents</span>:[<br>                   <span class="hljs-string">&#x27;a&#x27;</span>,<br>                   <span class="hljs-string">&#x27;b&#x27;</span>,<br>                   <span class="hljs-string">&#x27;c&#x27;</span>...<br>               ],<br>               <span class="hljs-attr">index</span>:<span class="hljs-number">0</span><br>           &#125;<br>       &#125;,<br>       <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-variable language_">window</span>.<span class="hljs-property">myData</span> = <span class="hljs-variable language_">this</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">routeData</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">method</span>()<br>       &#125;,<br>       <span class="hljs-attr">methods</span>:&#123;<br>           <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>)&#123;<br>               <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;/.../loginByUsername&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">routeData</span>.<span class="hljs-property">data</span>)<br>                 .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                   <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">XXcomponents</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i == <span class="hljs-variable language_">this</span>.<span class="hljs-property">routeData</span>.<span class="hljs-property">name</span> )<br>                   ...<br>               &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                   ...<br>               &#125;)<br>           &#125;<br>       &#125;,<br>       <span class="hljs-attr">components</span>:&#123;<br>             a,<br>             b,<br>             c...<br>       &#125;       <br>   &#125; <br>        <br>&lt;script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>这里的template标签呈现前端内容，可以看到只有一个:is绑定的动态组件，联想一下我们要做的是连接迁移，所以有理由可以<strong>猜想</strong>这里的components可能是根据index确定传入的页面是什么，然后在前端展示。</p>
<p>于是我自然地去看data属性里面的数据，可以看到XXcomponents对应的正好也是components属性里面的组件，这些组件是通过import导入的其他已经写好的Vue页面，这证实了我的猜想。</p>
<p>现在，我们已经知道了前端是怎么通过一个Vue页面实现连接迁移的功能了：</p>
<blockquote>
<p>通过切换index切换列表里面要展示的Vue页面</p>
</blockquote>
<p>那么，后端呢？</p>
<p>我看到这里Vue的生命周期create里面有写this.$route.query，这说明这个Vue页面创建的时候需要接收参数，这里的参数是直接写在网址里面的，this.$route.query的结果被写入了this.routeData，那后面的代码出现了this.routeData.name和this.routeData.data，那有理由相信传入链接里面的参数应该是类似这个样子的，例如：</p>
<blockquote>
<p> localhost:8888&#x2F;index&#x2F;data&#x3D;123&amp;name&#x3D;123</p>
</blockquote>
<p>那传入的数据就是:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>data<span class="hljs-punctuation">:</span><span class="hljs-number">123</span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span><span class="hljs-number">123</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>接收参数的事情往往和后端就有关系了，那它接收什么参数呢？</p>
<p>暂时不知道了，但是后面有个method方法，这个方法内部使用了异步的dispatch方法，向一个叫做loginByUsername的方法发送了参数，发送的值是我们前文提到的链接中的name属性对应的值。</p>
<p>现在，前端访问了后端一个叫做loginByUsername的方法了，并且把其中的name属性对应的值以Json格式传递了过去。</p>
<p>打开后端idea，输入：<strong>ctrl + shift + f</strong>，寻找匹配的loginByUsername方法。</p>
<p>很快我就找到了匹配的方法，一个写在@Controller里面的@PostMapping方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> WebResult <span class="hljs-title function_">loginByUsername</span> <span class="hljs-params">(<span class="hljs-meta">@Requestbody</span> UserNameDTO userNameDTO)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> (userNameDTO.getUserName())<br>    <span class="hljs-comment">// get token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> ...(userName);<br>    ......    <br>    <span class="hljs-keyword">return</span> WebResult.ok(token);<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserNameDTO</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> String userName;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法接收一个@Requestbody 的UserNameDTO实体类，然后用它获取username，把username通过Service层封装好的方法经过Base64加密后作为认证信息返回给前端。（WebResult是一个封装好的类，用于定制返回值到WSDL的映射）</p>
<p>至此，后端的功能也确认了：</p>
<blockquote>
<p>后端需要前端传入的userName信息，然后通过userName产生一个用于身份验证、网页跳转即连接迁移的token返回给前端。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后，链接的data属性将会被后面的findIndex方法用作确定index，然后根据index匹配对应的vue页面进行展示。</p>
<p>到此，我们可以通过访问如下链接：</p>
<blockquote>
<p>localhost:8888&#x2F;index&#x2F;data&#x3D;study&amp;name&#x3D;James</p>
</blockquote>
<p>匹配到一个属于James的study.vue前端界面，并展示对应的信息。</p>
<p>总的来说，这个需求并不难，其中核心的功能实现，例如dispatch对应的网址，根据Index匹配对应的vue页面，后端的token生成等功能的实现已经被封装了。不过作为第一个需求，对我来说也有一定难度，更重要的是学会了</p>
<ol>
<li><strong>如何在企业项目中理清思路——通过前端代码反推后端代码</strong></li>
<li><strong>重要的ctrl + shift + f</strong></li>
</ol>
<hr>
<h2 id="点击下钻跳转新页面"><a href="#点击下钻跳转新页面" class="headerlink" title="点击下钻跳转新页面"></a>点击下钻跳转新页面</h2><hr>
<p>独立项目开始了</p>
<h3 id="需求描述-1"><a href="#需求描述-1" class="headerlink" title="需求描述"></a>需求描述</h3><p>对Vue 表格中的表格数据新增一个点击方法，点击数据可以跳转一个新页面，新页面有点击数据的详细信息。</p>
<p>假设我现在有一个已经实现的饼状图，显示出ABCD四个岗位的百分比，同时饼状图下方是一个表格，显示了岗位名，人数和百分比，大致如下所示：</p>
<p>​                                    <strong>【饼状图】</strong></p>
<table>
<thead>
<tr>
<th align="center">岗位类型</th>
<th align="center">人数</th>
<th align="center">百分比</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">100</td>
<td align="center">10%</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">200</td>
<td align="center">20%</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">300</td>
<td align="center">30%</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">400</td>
<td align="center">40%</td>
</tr>
</tbody></table>
<p>现在需要当我们点击人数的时候（即点击上面表格中的100），会跳转到一个新页面，新页面使用表格形式显示这100个人的信息，同时实现分页。如下所示：</p>
<table>
<thead>
<tr>
<th>岗位类型</th>
<th>姓名</th>
<th>工号</th>
<th>部门</th>
<th>职位</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>pyrrhic</td>
<td>025618</td>
<td>IT</td>
<td>Staff</td>
<td>M</td>
</tr>
<tr>
<td>A</td>
<td>Mike</td>
<td>159736</td>
<td>Business</td>
<td>CEO</td>
<td>F</td>
</tr>
<tr>
<td>A</td>
<td>Done</td>
<td>789156</td>
<td>IT</td>
<td>Junior</td>
<td>F</td>
</tr>
</tbody></table>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>看到需求，我思考了一下，觉得需要解决的问题是：</p>
<ul>
<li><p>怎么添加前端的点击事件？</p>
</li>
<li><p>前端怎么实现跳转新页面？</p>
</li>
<li><p>新页面需要实现哪些功能？</p>
</li>
<li><p>原数据已经有了，我应该怎么获取？在哪里获取？</p>
</li>
<li><p>前后端分别需要什么参数？</p>
</li>
</ul>
<h3 id="思路与实现-1"><a href="#思路与实现-1" class="headerlink" title="思路与实现"></a>思路与实现</h3><p>在这里，与上一个项目不同，这里不仅需要前端代码反推后端，新的解决企业项目的思路是：</p>
<blockquote>
<p><strong>通过思考问题解决需求</strong></p>
</blockquote>
<h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><ul>
<li>第一个问题：<strong>怎么添加前端的点击事件</strong></li>
</ul>
<p>这里原本功能的实现者使用的element-ui的el-table实现表格功能，但是我们知道Vue表格的数据不是写死的，而是通过:data动态绑定的，el-table组件也没有列绑定事件，那应该怎么才能给对应的列添加点击事件呢？</p>
<p>这里困扰了我很久，网上相关的模棱两可的说法有太多了，也没有找到很合适的。最后我决定查看已经实现的其他页面，寻找可能的解决方案。这诞生了一个新的解决企业项目的思路：</p>
<blockquote>
<p><strong>举一反三</strong></p>
</blockquote>
<p>通过我不懈的思考和寻找，我发现在另外一个页面同样实现了类似的需求。它虽然没有给数据里面添加点击事件，但是它对表格内的某一列的数据做了判断，如果为空即返回“空”字符串。</p>
<p>这给了我一个启示，只要这么写就好：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;template #value = <span class="hljs-string">&quot;scope&quot;</span>&gt;<br>	<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;employeeDetail(scope.row)&quot;</span>&gt;</span>&#123;&#123;scope.row.value&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>    <br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure>

<p>通过#号绑定data里面带有slot属性的列，再调用click方法，Vue就能找到对应的方法了。这里的方法需要能够跳转新页面。</p>
<ul>
<li>那么，第二个问题：<strong>前端怎么实现跳转新页面？</strong></li>
</ul>
<p>这里需要使用push方法，即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">employeeDetail</span>(<span class="hljs-params">row</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-title function_">push</span>(&#123;<br>            <span class="hljs-attr">name</span>: ...,<br>            <span class="hljs-attr">params</span>:&#123;<br>                ...<br>            &#125;<br>        &#125;)<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>

<p>很显然，找到公司代码山里面的router.vue，添加你要跳转的页面名字和链接，同时指向一个新的你要创建的Vue组件——你即将创建的Vue组件就是新的页面，现在只需要create一个new file即可！</p>
<ul>
<li>现在第三个问题：<strong>新页面需要实现哪些功能？</strong></li>
</ul>
<p>很显然，我需要一个 el-table 表格存放后端传来的数据，我还需要一个pagination标签对表格进行分页。</p>
<p>至此，前端的基本框架和内容已经基本架构完毕了，现在看看后端</p>
<h4 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h4><ul>
<li>第四个问题：<strong>原数据已经有了，我应该怎么获取？在哪里获取？</strong></li>
<li>第五个问题：<strong>前后端分别需要什么参数？</strong></li>
</ul>
<p>这两个问题都可以通过分析后端解决。</p>
<p>通过分析后端方法，能了解到后端这里获取员工数量是通过这样的逻辑：</p>
<blockquote>
<p>Controller -&gt; Service -&gt; Mapper -&gt; SQL</p>
</blockquote>
<p>最后通过SQL的count函数获取的人数，大致如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(employeeId) <span class="hljs-keyword">as</span> A<br><span class="hljs-keyword">from</span> ... <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> ...<br><span class="hljs-keyword">where</span> deptId <span class="hljs-operator">=</span> #&#123;deptId&#125; <br><span class="hljs-keyword">and</span> jobType <span class="hljs-operator">=</span> #&#123;jobType&#125;<br><span class="hljs-keyword">and</span> ...<br></code></pre></td></tr></table></figure>

<p>这里吐槽一下公司用的BeetlSQL + Oracle SQL这种梦幻组合，有很多不同于之前了解的Mysql语法，而且还能添加 if函数，可以说非常奇特，让我大开眼界。</p>
<p>那这个逻辑稍微修改一下就可以获得员工的详细信息了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> jobType,Name,employeeId,dept,position,sex<br><span class="hljs-keyword">from</span> ... <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> ...<br><span class="hljs-keyword">where</span> deptId <span class="hljs-operator">=</span> #&#123;deptId&#125; <br><span class="hljs-keyword">and</span> jobType <span class="hljs-operator">=</span> #&#123;jobType&#125;<br><span class="hljs-keyword">and</span> ...<br></code></pre></td></tr></table></figure>

<p>参数什么的都不需要改，可以说很方便了。而且也可以猜到，需要的参数应该就是部门ID（deptId）和工作类型（jobType）了。另外分页可能也需要参数 page 和limit。</p>
<p>只需要新建一个VO类，存放返回的 jobType,Name,employeeId,dept,position,sex 信息即可，略过Controller类和Service类代码，直接看Service层的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PageResult&lt;BaseVO&gt; <span class="hljs-title function_">findEmployeeDetail</span><span class="hljs-params">(BaseDTO query)</span>&#123;<br>    <span class="hljs-comment">// If deptId is null, set a default id by its login session</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(query.getDeptId()))&#123;<br>        query.setDeptId(getDefaultDeptId());<br>    &#125;<br>    <span class="hljs-comment">// Extract parameters except pagination parameters</span><br>    Map&lt;String,Object&gt; pageParam = query.getPageParam();<br>    <br>    PageResult&lt;BaseVO&gt; BaseVOs = mapper.findEmployeeDetail(query,pageParam);<br>    <span class="hljs-keyword">return</span> BaseVOs;<br>        <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里防止了一个空指针，然后还完成了分页逻辑，只需要向前端索要上一个页面传递的参数即可。</p>
<p>至此，后端需要做的事情也基本清楚了，需求的整体已经很清晰了。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>最后，在新页面，前端可以通过api的方法传递参数（接收上一个页面push过来的<code>this.$router.params.deptId</code>等等），再多传入几个分页参数，例如<code>page:1</code> 和 <code>limit:10</code> 。最后调用Controller方法，返回的数据，前端通过<code>.then(res =&gt; ...)</code> 来接收即可。</p>
<p>这个需求相比上一个已经有了一点难度，更重要的是又有了两个解决项目需求的思路：</p>
<ol>
<li><strong>通过思考问题解决需求</strong></li>
<li><strong>举一反三</strong></li>
</ol>
<hr>
<h2 id="定时调度邮件任务优化"><a href="#定时调度邮件任务优化" class="headerlink" title="定时调度邮件任务优化"></a>定时调度邮件任务优化</h2><hr>
<h3 id="需求描述-2"><a href="#需求描述-2" class="headerlink" title="需求描述"></a>需求描述</h3><p>上一任设计定时调度任务的员工为图省事，在接收到调度任务的数据后，直接以toString的方式返回了数据，导致每次邮件内容都长这样：</p>
<p><img src="/images/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82%EF%BC%881%EF%BC%89.png" alt="项目记录——企业需求"></p>
<p>很显然，这不是利于人类阅读的模式，因此这个需求要求我更改这个需求的样式，把这些数据按照表格的形式展示出来，同时附件带有EXCEL文件。合理的样式应该如下所示：</p>
<p><img src="/images/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82%EF%BC%882%EF%BC%89.png" alt="项目记录——企业需求（2）"></p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>看到需求，接下来需要解决的问题是：</p>
<ul>
<li><p>定时任务怎么调试？</p>
</li>
<li><p>获取的数据长什么样子？</p>
</li>
<li><p>应该怎么实现EXCEL作为附件写入邮件？</p>
</li>
<li><p>怎么让邮件按照需要的样子进行展示？</p>
</li>
</ul>
<h3 id="思路与实现-2"><a href="#思路与实现-2" class="headerlink" title="思路与实现"></a>思路与实现</h3><p>这个项目更多的是拓展了我的见识，了解了如何使用定时调度任务，以及了解了EasyPoi的导出excel等功能。</p>
<p>另外，这是一个纯后端项目：</p>
<h4 id="后端-2"><a href="#后端-2" class="headerlink" title="后端"></a>后端</h4><p>首先，这个代码已经完成的阶段大概是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(cron = &quot;0 0 23 * * ?&quot;)</span><br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeEmployee</span><span class="hljs-params">()</span> <span class="hljs-keyword">throw</span> Exception&#123;<br>    ... get data by SQL ...<br>        <br>    List&lt;sysUserEntity&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;businessUserEntity&gt; arrList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    ... put data into these two arraylist ...<br>        <br>    MailUtil.send(<span class="hljs-string">&quot;...@...&quot;</span>,userList.toString,...);<br>    MailUtil.send(<span class="hljs-string">&quot;...@...&quot;</span>,arrList.toString,...);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，根据我们之前提到的解决项目需求的方法思考：</p>
<blockquote>
<p><strong>通过思考问题解决需求</strong></p>
</blockquote>
<p>针对第一个问题，<strong>定时任务怎么调试？</strong></p>
<p>调试定时任务的方法可以参考之前我发的<a href="https://thellu.com/2023/06/08/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E9%9C%80%E6%B1%82/">另一个帖子</a> 。</p>
<p>第二个问题，<strong>获取的数据长什么样子？</strong></p>
<p>之前的代码中，发送任务执行了两次，并且发送的是userList和arrList两个数组，这两个数组包装了sysUserEntity和businessUserEntity 两个实体类，所以我们可以想到发送的就是这两个实体类的数据。</p>
<p>而要同时发送两次，它们可能有大同小异的操作，所以我想到可能这里需要写一个泛型方法去接收这两个实体类。</p>
<p>第三个问题，<strong>应该怎么实现EXCEL作为附件写入邮件？</strong></p>
<p>这里可能就应该用到一些API了，例如 <code>Hutool MailUtil.send</code>方法发送邮件。</p>
<p>这个方法接收邮箱名等参数，更重要的是它还接收一个html模板参数，所以在这里我们可以写一个btl模板配置文件用于优化原本的邮件格式。</p>
<p>到此，基本的思路就已经有了。</p>
<p>第四个问题，<strong>怎么让邮件按照需要的样子进行展示？</strong></p>
<p>这个问题需要一步一步分析，并且它可以拓展为很多小问题。</p>
<p>首先，我们打算使用<code>Hutool MailUtil.send</code>方法发送邮件，这个方法接收什么参数呢？</p>
<h5 id="MailUtil-send"><a href="#MailUtil-send" class="headerlink" title="MailUtil.send"></a>MailUtil.send</h5><p>因为这个方法被重载过，所以我直接介绍我们要用的方法的参数：</p>
<p>Hutool的这个方法的<strong>源码</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送邮件给多人</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> tos 收件人列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> subject 标题</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> content 正文</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isHtml 是否为HTML格式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> files 附件列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">( Collection&lt;String&gt; tos, String subject, String content, <span class="hljs-type">boolean</span> isHtml, File... files)</span> &#123;<br>  Mail.setTos(tos.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[tos.size()]))<span class="hljs-comment">//</span><br>      .setTitle(subject)<span class="hljs-comment">//</span><br>      .setContent(content)<span class="hljs-comment">//</span><br>      .setHtml(isHtml)<span class="hljs-comment">//</span><br>      .setFiles(files)<span class="hljs-comment">//</span><br>      .send();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结一下，它需要这些参数：</p>
<ul>
<li>tos 收件人，正常可以设置多个，这里只有一个收件人</li>
<li>subject 邮件标题</li>
<li>content 邮件正文，可以是文本，也可以是HTML内容</li>
<li>isHtml 是否为HTML，如果是，那参数3识别为HTML内容</li>
<li>File 可选：附件，可以为多个或没有，将File对象加在最后一个可变参数中即可</li>
</ul>
<p>所以，可以看出来，如果我们希望修改邮件的格式，需要增加一个html页面在参数中。而且，这个html页面还需要把数据传进去，在邮件中显示出来。所以，这里我使用了<code>BeelUtil</code>的<code>template</code>，它需要一个<code>btl</code>文件。</p>
<p>这个文件按照html格式在邮件开头增加了</p>
<p>“Dear Manager: Employee who resigned … “ 这段话，同时用 td 等html标签生成了一个表格，数据采用 <code>jsp</code> 动态生成，这里就不详细展示了。</p>
<p>这里想要使用 BeelUtil 导入模板的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">GroupTemplate</span> <span class="hljs-variable">gt</span> <span class="hljs-operator">=</span> BeelUtil.getGt();<br><span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> gt.getTemplate(templateKeyPath);<br>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;lists&quot;</span>,listsCopy);<br>template.binding(map)<br></code></pre></td></tr></table></figure>

<p>templateKeyPath 是 btl 文件的路径，listsCopy是复制的arraylist的数据。之所以要复制一份，是因为如果不复制一份用原数据的话，template 在binding之后这些数据就消失了，最后对导致 template 找不到需要的数据，发出一个空邮件。</p>
<h5 id="Excel-导出"><a href="#Excel-导出" class="headerlink" title="Excel 导出"></a>Excel 导出</h5><p>搞定模板了，现在由于我们还需要在邮件中添加一个excel附件，所以需要先把这些数据导出到一个excel里面，然后最后把这个excel文件放在 <code>MailUtil.send</code> 的参数里面。</p>
<p>Excel文件的导出，这里选用的是 <code>EasyPoi</code> 的<code>ExcelExportUtil.exportExcel</code> 方法</p>
<p>这个方法也有很多次重载，选择我们要使用的，<strong>源码</strong>展示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 根据Entity创建对应的Excel</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> entity</span><br><span class="hljs-comment">	 *            表格标题属性</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> pojoClass</span><br><span class="hljs-comment">	 *            Excel对象Class</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> dataSet</span><br><span class="hljs-comment">	 *            Excel对象数据List</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Workbook <span class="hljs-title function_">exportExcel</span><span class="hljs-params">(ExportParams entity, Class&lt;?&gt; pojoClass, Collection&lt;?&gt; dataSet)</span> &#123;<br>		Workbook workbook;<br>		<span class="hljs-keyword">if</span> (ExcelType.HSSF.equals(entity.getType())) &#123;<br>			workbook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>();<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataSet.size() &lt; <span class="hljs-number">1000</span>) &#123;<br>			workbook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>();<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			workbook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SXSSFWorkbook</span>();<br>		&#125;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExcelExportServer</span>().createSheet(workbook, entity, pojoClass, dataSet,<span class="hljs-literal">null</span>);<br>		<span class="hljs-keyword">return</span> workbook;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>可见，<code>exportExcel</code> 方法需要的参数是：</p>
<ul>
<li>entity exportParams类，这个类里面包含了excel文件的各种属性，例如标题，标题行内容等等</li>
<li>pojoClass 需要转变的entity类，在这个例子里面就是<code>sysUserEntity.class</code> 和 <code>businessUserEntity.class</code></li>
<li>dataSet 传入的数据</li>
</ul>
<p>这里出于隐私角度，不详细介绍我要在这里设置的exportParams了，而是封装在<code>getExportParams</code>方法里面了。最后把导出的excel读入作为 <code>MailUtil.send</code> 的参数使用。具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// set title in excel    </span><br><span class="hljs-type">ExportParams</span> <span class="hljs-variable">export</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getExportParams(title);<br>        <br><span class="hljs-comment">// export Excel</span><br><span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> ExcelExportUtil.exportExcel(export,entityClass,lists);<br>...<br>com.spire.xls.<span class="hljs-type">Workbook</span> <span class="hljs-variable">_workbook</span> <span class="hljs-operator">=</span> poiUtils.convertToSpireWorkbook(workbook);<br><span class="hljs-comment">// encapsulation file outputStream method</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getFileAttach(_workbook);<br><span class="hljs-comment">// send email</span><br>MailUtil.send(<span class="hljs-string">&quot;....@...&quot;</span>,subjectTitle,template.render(),<span class="hljs-literal">true</span>,file);<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>title</code> 是要手动传入的标题字符串，通过getExportParams设置为excel 内部的标题。</p>
</li>
<li><p><code>subjectTitle</code>  是要手动传入的邮件标题字符串。</p>
</li>
<li><p><code>template.render()</code> 是对前文获取到的template模板进行渲染</p>
</li>
</ul>
<p>但是这里有个问题，这个 entityClass 是需要的类，而对这个例子，我们知道，指的是<code>sysUserEntity.class</code> 和 <code>businessUserEntity.class</code>，可是这是个泛型方法！因为类型擦除的原因，你不能直接获取 <code>T.class</code> 。</p>
<p>那么，问题来了——怎么获取泛型类型？</p>
<h5 id="反射获取泛型Class对象"><a href="#反射获取泛型Class对象" class="headerlink" title="反射获取泛型Class对象"></a>反射获取泛型Class对象</h5><p>在idea 里面尝试写 <code>T.class</code> 连编译都无法通过，那么应该怎么办呢？</p>
<p>虽然泛型会在字节码编译过程中被擦除，但是<code>Class</code>对象会通过<code>java.lang.reflect.Type</code>记录其实现的接口和继承的父类信息。我们以<code>ArrayList&lt;E&gt;</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> strings.getClass().getGenericSuperclass();<br><span class="hljs-comment">// genericInterfaces = java.util.AbstractList&lt;E&gt;</span><br>System.out.println(<span class="hljs-string">&quot;genericSuperclass = &quot;</span> + genericSuperclass);<br></code></pre></td></tr></table></figure>

<p>结果是 占位符 E。</p>
<p>但是显然，我们想要的是String 而不是那个E。</p>
<p>genericSuperclass 是 <code>Type</code> 类型，而<code>Type</code>有四种类型：</p>
<ul>
<li><code>GenericArrayType</code> 用来描述一个参数泛型化的数组。</li>
<li><code>WildcardType</code> 用来描述通配符<code>?</code>相关的泛型，包含的<code>?</code>、下界通配符<code>? super E</code> 、上界通配符<code>? extend E</code>。</li>
<li><code>Class&lt;T&gt;</code> 用来描述类的<code>Class</code>对象。</li>
<li><code>ParameterizedType</code> 用来描述参数化类型。</li>
</ul>
<p>看看instanceof 它们分别会输出什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <br><span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> strings.getClass().getGenericSuperclass();<br> <br>System.out.println( genericSuperclass <span class="hljs-keyword">instanceof</span> ParameterizedType); <span class="hljs-comment">// true</span><br>System.out.println( genericSuperclass <span class="hljs-keyword">instanceof</span> Class); <span class="hljs-comment">// false</span><br>System.out.println( genericSuperclass <span class="hljs-keyword">instanceof</span> WildcardType); <span class="hljs-comment">// false</span><br>System.out.println( genericSuperclass <span class="hljs-keyword">instanceof</span> GenericArrayType); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>所以，选择参数化类型方法能获得什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) genericSuperclass;<br>Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();<br>System.out.println(<span class="hljs-string">&quot;actualTypeArguments = &quot;</span> + Arrays.toString(actualTypeArguments));<br></code></pre></td></tr></table></figure>

<p>返回的Type[] 数组里面只有一个 [E]，看来结果还是E，似乎失败了。</p>
<p>但是为什么呢？</p>
<p>原因其实在ArrayList上，看看ArrayList的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>... <br>&#125;<br></code></pre></td></tr></table></figure>

<p>ArrayList实例化时只指定了自己的泛型类型而没有指定父类<code>AbstractList</code>的具体泛型，所以获取到的还是占位符<code>E</code>。</p>
<p>那在这里，实际操作的时候，我要是就是想要 arrayList<String> 里面的 String 类型应该怎么办呢？</p>
<p>实际上有个简单的方法：（构建匿名子类实现）</p>
<blockquote>
<p>ArrayList<String> strings &#x3D; new ArrayList<String>(){}; &#x2F;&#x2F; 看这里最后加了个大括号</p>
</blockquote>
<p>我们通过大括号<code>&#123;&#125;</code>就可以重写实现父类的方法并指定父类的泛型具体类型。为什么呢？因为加一个大括号这种写法相当于是定义匿名内部类，编译时可以确定类型为String。</p>
<p>那项目这里我们就可以这么写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> lists.getClass().getGenericSuperclass();<br>Class&lt;?&gt; entityClass = (Class&lt;?&gt;)((ParameterizedType) genericSuperclass).getActualTypeArguments()[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<p>lists 就是我们要传入的 ArrayList<T> 了。</p>
<h5 id="在配置文件设置收件人"><a href="#在配置文件设置收件人" class="headerlink" title="在配置文件设置收件人"></a>在配置文件设置收件人</h5><p>到这一步，基本上代码已经完成了，但是目前收件人的邮箱是固定的，固定在 <code>MailUtil.send</code> 的第一个参数里面。</p>
<p>如果我还希望在配置文件里面更改这个收件人邮箱怎么办呢？</p>
<p>很简单，在 application.properties 里面设置键值对：</p>
<blockquote>
<p>auto.email&#x3D;”<a href="mailto:&#97;&#x61;&#x61;&#97;&#x61;&#64;&#98;&#98;&#98;&#98;&#98;&#x2e;&#x63;&#x6f;&#109;">&#97;&#x61;&#x61;&#97;&#x61;&#64;&#98;&#98;&#98;&#98;&#98;&#x2e;&#x63;&#x6f;&#109;</a>“</p>
</blockquote>
<p>在Java Bean注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;auto.email&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String email;<br></code></pre></td></tr></table></figure>

<p>然后在 <code>MailUtil.send</code> 的参数里面写 <code>this.email</code> 即可。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>完全的代码大致如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;auto.email&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String email;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendDeletedEmployeeAuto</span><span class="hljs-params">(List&lt;T&gt; lists, String templateKeyPath,String subjectTitle,</span><br><span class="hljs-params">                                       String title)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(lists) &amp;&amp; lists.size() &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// Get the generic type</span><br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> lists.getClass().getGenericSuperclass();<br>        Class&lt;?&gt; entityClass = (Class&lt;?&gt;)((ParameterizedType) genericSuperclass).getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-comment">// Copy arraylist to help template read</span><br>        List&lt;T&gt; listsCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrrayList</span>&lt;&gt;();<br>        listsCopy = ListUtil.toCopyOnWriteArrayList(lists);<br>        <br>        <span class="hljs-comment">// template</span><br>        <span class="hljs-type">GroupTemplate</span> <span class="hljs-variable">gt</span> <span class="hljs-operator">=</span> BeelUtil.getGt();<br>        <span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> gt.getTemplate(templateKeyPath);<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;lists&quot;</span>,listsCopy);<br>        template.binding(map)<br>            <br>        <span class="hljs-comment">// set title in excel    </span><br>        <span class="hljs-type">ExportParams</span> <span class="hljs-variable">export</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getExportParams(title);<br>        <br>        <span class="hljs-comment">// export Excel</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> ExcelExportUtil.exportExcel(export,entityClass,lists);<br>        ...<br>        com.spire.xls.<span class="hljs-type">Workbook</span> <span class="hljs-variable">_workbook</span> <span class="hljs-operator">=</span> poiUtils.convertToSpireWorkbook(workbook);<br>        <span class="hljs-comment">// encapsulation file outputStream method</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getFileAttach(_workbook);<br>        <span class="hljs-comment">// send email</span><br>        MailUtil.send(<span class="hljs-built_in">this</span>.email,subjectTitle,template.render(),<span class="hljs-literal">true</span>,file);<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>发送邮件后就可以按需求的样子展示了，具体的样式看自己写的html文件了。</p>
<p>这个需求是我之前没接触过的全新项目，还尝试了自己写一个泛型方法，可以说很有意思了。主要学习到了：</p>
<ol>
<li><strong><code>Hutool</code> 的 <code>MailUtil.send</code> 方法的使用</strong></li>
<li><strong><code>EasyPoi</code> 的<code>ExcelExportUtil.exportExcel</code> 方法使用</strong></li>
<li><strong>如何通过反射获取泛型类型</strong></li>
<li><strong>如何把配置文件属性注入类中使用</strong></li>
</ol>
<hr>
<hr>
<h2 id="具有下拉框-x2F-直方图的报表"><a href="#具有下拉框-x2F-直方图的报表" class="headerlink" title="具有下拉框&#x2F;直方图的报表"></a>具有下拉框&#x2F;直方图的报表</h2><hr>
<p>这是一个新的特别完整的页面报表需求，包含有下拉框设计以及对应的数据收集和限制，以及数据直方图在Vue的显示等。</p>
<h3 id="需求描述-3"><a href="#需求描述-3" class="headerlink" title="需求描述"></a>需求描述</h3><p>需要构建类似如下的画面，包含的基本功能需求有：</p>
<p><img src="D:\Blog\hexo\source\images\项目记录——企业需求\项目记录——企业需求（3）.png" alt="项目记录-企业需求3"></p>
<ul>
<li>下拉框功能实现</li>
<li>强制先选择项目才能获取line和process</li>
<li>直方图的实现</li>
<li>日期选择的实现</li>
<li>姓名，员工id的input框</li>
<li>数据表格的实现</li>
</ul>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>正如在需求描述中所写的一样，需要实现的功能与我的问题高度相关：</p>
<ul>
<li><p>下拉框功能应该怎么实现？</p>
</li>
<li><p>部门树应该怎么获取？</p>
</li>
<li><p>line和process需要先获取项目了再显示，应该怎么做？</p>
</li>
<li><p>动态的直方图功能应该怎么实现？</p>
</li>
<li><p>日期、姓名、员工id等参数怎么在后端做查询？</p>
</li>
<li><p>表格数据应该怎么呈现？</p>
</li>
</ul>
<h3 id="思路与实现-3"><a href="#思路与实现-3" class="headerlink" title="思路与实现"></a>思路与实现</h3><p>这个项目涉及了很多功能的实现，让我们一步一步的思考，这次不会再区分前后端代码，而是围绕需求或者说问题去分析，因为一个功能往往是既涉及前端代码也涉及到后端代码的。如果围绕需求或者说问题去分析，可能更容易理解一点。</p>
<h4 id="Dept部门树级联选择器"><a href="#Dept部门树级联选择器" class="headerlink" title="Dept部门树级联选择器"></a>Dept部门树级联选择器</h4><p>这一块<strong>我不会详谈</strong>，因为既涉及到了公司隐私，而且也是个已经完成的接口，后端直接调用该接口，传递给前端即可。</p>
<p>这里的前端代码是利用<strong>element-ui</strong>的cascader实现的，Vue代码如下：</p>
<p>（注意尽管封装好了一个cust-cascader组件，但是功能和<strong>el-cascader</strong>差不多）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;cust-cascader<br>	v-model=<span class="hljs-string">&quot;queryParam.deptCode&quot;</span><br>	<span class="hljs-keyword">class</span>= <span class="hljs-string">&quot;filter-item&quot;</span> <br>	:placeholder=<span class="hljs-string">&quot;Dept&quot;</span><br>	:props = <span class="hljs-string">&quot;&#123;value:&#x27;deptId&#x27;,label:&#x27;name&#x27;&#125;&quot;</span><br>	:show-all-levels=<span class="hljs-string">&quot;false&quot;</span><br>	:options=<span class="hljs-string">&quot;orgTree.treeList&quot;</span><br>	ref=<span class="hljs-string">&quot;cascader&quot;</span><br>	size=<span class="hljs-string">&quot;mini&quot;</span><br>	style=<span class="hljs-string">&quot;float:left;margin-right:15px;&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>v-model</code>绑定的数据是未来会通过前端传递给后端的；</li>
<li><code>class,style,size</code>等属性用于美化；</li>
<li><code>show-all-levels</code>属性属于<strong>el-cascader</strong>的一部分，用于确定输入框中是否显示选中值的完整路径（即部门树的完整路径）</li>
<li><code>placeholder</code>显示文字在框内</li>
</ul>
<p>那么这个下拉框的原始数据是从哪里来的呢？——通过options和<code>props</code>组合获取，<code>:options</code>获取的orgTree的treeList，这个treeList是从<code>data</code>属性获取的，<code>data</code>的属性又通过放在<code>created</code>里面的方法实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">orgTree</span>:&#123;<br>            <span class="hljs-attr">treeList</span>:[],<br>            <span class="hljs-attr">selectId</span>:<span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">defaultProps</span>:&#123;<br>                <span class="hljs-attr">children</span>:<span class="hljs-string">&quot;children&quot;</span>,<br>                <span class="hljs-attr">label</span>:<span class="hljs-string">&quot;label&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;,<br>    <br><span class="hljs-keyword">import</span> api <span class="hljs-keyword">from</span> ...<br><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">handleOrgTreeList</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> api.<span class="hljs-title function_">getOrgList</span>(&#123;<span class="hljs-attr">orderBy</span>:<span class="hljs-string">&quot;orderNum&quot;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> data = res.<span class="hljs-property">data</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">orgTree</span>.<span class="hljs-property">treeList</span> = data;<br>        &#125;)<br>    &#125;        <br>&#125;,<br>    <br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleOrgTreeList</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.$isNotEmpty(<span class="hljs-variable language_">this</span>.<span class="hljs-property">orgTree</span>.<span class="hljs-property">treeList</span>))&#123;<br>            <span class="hljs-keyword">const</span> firstNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">orgTree</span>.<span class="hljs-property">treeList</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可见，当组件创建的时候，调用了<code>handleOrgTreeList</code>方法，即调用了后端接口，为orgTree.treeList赋值，然后在DOM渲染完毕后自然放进了级联选择器中显示出来了。</p>
<h4 id="Project与Type-下拉框"><a href="#Project与Type-下拉框" class="headerlink" title="Project与Type 下拉框"></a>Project与Type 下拉框</h4><p>我们知道，按照正常的设计逻辑，下拉框的内容肯定应该是在用户点击的时候就显示出来，而不是等待用户输入几个字符之后才开始搜索数据并显示，因此这里很自然能想到应该把方法的实现写在created里面。</p>
<p>事实上这两个下拉框的实现逻辑是一样的，我在这里以Type下拉框作为例子展示，Project下拉框和Type下拉框的差距仅仅在SQL查询上。</p>
<p>这次首先先写后端的内容，后端首先在Controller类里面完成一个很简单的代码逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(&quot;...&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/bi&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseController</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BaseService baseService;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseController</span><span class="hljs-params">(BaseService baseService)</span>&#123;<br>        <span class="hljs-comment">// Constructor injection. If the code is bloated later, can add @AllArgsConstructora to remove 				this part</span><br>        <span class="hljs-built_in">this</span>.baseService = baseService;<br>    &#125;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/type&quot;)</span><br>    <span class="hljs-meta">@ApiOperation</span><br>    <span class="hljs-keyword">public</span> WebResult&lt;List&lt;BaseEmployeeEntity&gt;&gt; <span class="hljs-title function_">findType</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> QueryParams queryParam)</span>&#123;<br>        &lt;List&lt;BaseEmployeeEntity&gt;&gt; list = baseService.findType(queryParam);<br>        <span class="hljs-keyword">return</span> WebResult.ok(list);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>WebResult如之前所说，是一个封装好的类，用于定制返回值到WSDL的映射。</p>
<p>BaseEmployeeEntity，则是一个关联数据库的实体类，里面有很多字段，但是我们需要的只是关联type的那个字段，它将用于获取员工类型：A,B,C,D。</p>
<p>QueryParams类，一个封装的接收前端参数的类。</p>
<p>接下来，Service层和ServiceImpl层的代码如下所示：（比较基础）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysBaseService</span>&lt;BaseMapper,BaseEmployeeEntity&gt;&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> queryParam related to table,only needs type field</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a list of type field, now (A,B,C,D)</span><br><span class="hljs-comment">	*/</span><br>    List&lt;BaseEmployeeEntity&gt; <span class="hljs-title function_">findType</span><span class="hljs-params">(QueryParams queryParam)</span>;   <br>&#125;<br><br><br></code></pre></td></tr></table></figure>

























<p>BaseController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(&quot;...&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/bi&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseController</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BaseService baseService;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseController</span><span class="hljs-params">(BaseService baseService)</span>&#123;<br>        <span class="hljs-comment">// Constructor injection. If the code is bloated later, can add @AllArgsConstructora to remove 				this part</span><br>        <span class="hljs-built_in">this</span>.baseService = baseService;<br>    &#125;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/type&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;type information&quot;)</span><br>    <span class="hljs-keyword">public</span> WebResult&lt;List&lt;BaseEmployeeEntity&gt;&gt; <span class="hljs-title function_">findType</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> QueryParams queryParam)</span>&#123;<br>        &lt;List&lt;BaseEmployeeEntity&gt;&gt; list = baseService.findType(queryParam);<br>        <span class="hljs-keyword">return</span> WebResult.ok(list);<br>    &#125;    <br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/lineOrProcess&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;lineOrProcess information&quot;)</span><br>    <span class="hljs-keyword">public</span> WebResult&lt;List&lt;BaseEmployeeEntity&gt;&gt; <span class="hljs-title function_">findLineOrProcess</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> BaseEmployeeEntity queryParam)</span>&#123;<br>        &lt;List&lt;BaseEmployeeEntity&gt;&gt; list = baseService.findLineOrProcess(queryParam);<br>        <span class="hljs-keyword">return</span> WebResult.ok(list);<br>    &#125;     <br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/findDetail&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;find all information to table&quot;)</span><br>    <span class="hljs-keyword">public</span> WebResult&lt;BaseVO&gt; <span class="hljs-title function_">findDetail</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> BaseDTO queryParam)</span>&#123;<br>        PageResult&lt;BaseVO&gt; vo = baseService.findDetail(queryParam);<br>        <span class="hljs-keyword">return</span> WebResult.ok(vo);<br>    &#125;  <br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/plot&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;plot histogram&quot;)</span><br>    <span class="hljs-keyword">public</span> WebResult&lt;chartVO&gt; <span class="hljs-title function_">plotChart</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> chartDTO queryParam)</span>&#123;<br>        List&lt;chartVO&gt; vo = baseService.plotChart(queryParam);<br>        <span class="hljs-keyword">return</span> WebResult.ok(vo);<br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>BaseService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysBaseService</span>&lt;BaseMapper,BaseEmployeeEntity&gt;&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> queryParam related to table,only needs type field</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a list of type field, now (A,B,C,D)</span><br><span class="hljs-comment">	*/</span><br>    List&lt;BaseEmployeeEntity&gt; <span class="hljs-title function_">findType</span><span class="hljs-params">(QueryParams queryParam)</span>; <br>    <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * ...</span><br><span class="hljs-comment">	*/</span>    <br>    List&lt;BaseEmployeeEntity&gt; <span class="hljs-title function_">findLineOrProcess</span><span class="hljs-params">(BaseEmployeeEntity queryParam)</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * ...</span><br><span class="hljs-comment">	*/</span>    <br>    PageResult&lt;BaseVO&gt; <span class="hljs-title function_">findDetail</span><span class="hljs-params">(BaseDTO queryParam)</span>;<br>    <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * ...</span><br><span class="hljs-comment">	*/</span>    <br>    List&lt;chartVO&gt; <span class="hljs-title function_">plotChart</span><span class="hljs-params">(chartDTO queryParam)</span>;   <br>&#125;<br></code></pre></td></tr></table></figure>

<p>BaseServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysBaseServiceImpl</span>&lt;BaseMapper,BaseEmployeeEntity&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseService</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnotherService anotherService;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseServiceImpl</span><span class="hljs-params">(BaseServiceImpl baseServiceImpl)</span>&#123;<br>        <span class="hljs-comment">// Constructor injection. If the code is bloated later, can add @AllArgsConstructora to remove 				this part</span><br>        <span class="hljs-built_in">this</span>.anotherService = anotherService;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;BaseEmployeeEntity&gt; <span class="hljs-title function_">findLineOrProcess</span><span class="hljs-params">(BaseEmployeeEntity queryParam)</span>&#123;<br>        List&lt;BaseEmployeeEntity&gt; list;<br>        lists = mapper.findLineOrProcess(queryParams);<br>        <span class="hljs-keyword">return</span> lists;        <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;BaseEmployeeEntity&gt; <span class="hljs-title function_">findType</span><span class="hljs-params">(QueryParams queryParam)</span>&#123;<br>        LambdaQuery&lt;BaseEmployeeEntity&gt; query = sqlManager.lambdaQuery(BaseEmployeeEntity.class);<br>        <span class="hljs-comment">// deduplication and check not empty</span><br>        List&lt;BaseEmployeeEntity&gt; select = query.andIsNotNull(BaseEmployeeEntity::getType)<br>            .groupBy(BaseEmployeeEntity::getType)<br>            .select(BaseEmployeeEntity::getType);<br>        <span class="hljs-keyword">return</span> select;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    publci PageResult&lt;BaseVO&gt; <span class="hljs-title function_">findDetail</span><span class="hljs-params">(BaseDTO queryParam)</span>&#123;<br>        <span class="hljs-comment">// if deptCode is null, then give a default dept code by userId</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(queryParam.getDeptCode()))&#123;<br>            queryParam.setDeptCode(anotherService.setHighDeptCode());<br>        &#125;<br>        Map&lt;String,Object&gt; pageParam = query.getPageParam();<br>        PageResult&lt;BaseVO&gt; vos = mapper.findDetail(queryParam.getPageRequest(),pageParam);<br>        <span class="hljs-keyword">return</span> vos;        <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;chartVO&gt; <span class="hljs-title function_">plotChart</span><span class="hljs-params">(chartDTO queryParam)</span>&#123;<br>        <span class="hljs-comment">// if deptCode is null, then give a default dept code by userId</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(queryParam.getDeptCode()))&#123;<br>            queryParam.setDeptCode(anotherService.setHighDeptCode());<br>        &#125;<br>        List&lt;chartVO&gt; chartData = mapper.plotChart(queryParam);<br>		<span class="hljs-comment">//hashmap优化，待定</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/** return next N month data</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * ...</span><br><span class="hljs-comment">	*/</span>    <br>    <span class="hljs-keyword">private</span> List&lt;chartVO&gt; <span class="hljs-title function_">nextNmonthData</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        AyyayList&lt;chartVO&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(n);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br>        <span class="hljs-comment">// plus n month</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> today.plusMonth(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ym</span> <span class="hljs-operator">=</span> LocalDate.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-mm&quot;</span>));<br>            <span class="hljs-type">chartVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chartVO</span>();<br>            vo.setMonth(ym);<br>            vo.setCount(<span class="hljs-string">&quot;0&quot;</span>);<br>            arr.add(vo);<br>         &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>BaseEmployeeEntity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/** </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> lu</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@date</span> 2023/...</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">	 * ...</span><br><span class="hljs-comment">	*/</span>   <br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(&quot;BaseVO&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseEmployeeEntity</span>&#123;<br>    <br>    <span class="hljs-meta">@ApiModelProperty(&quot;Name&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    ...<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>BaseMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>







<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>1. </p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Vue</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>构造器内部初始化实际过程</title>
    <url>/2023/05/18/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h2><p>类的初始化遵循的顺序很多人都知道是这样：<br>（1）调用基类构造器，不断重复这个过程直到最底层<br>（2）再按照声明的顺序调用成员的初始化方法<br>（3）调用类构造器的主体  </p>
<h2 id="类初始化的实际过程"><a href="#类初始化的实际过程" class="headerlink" title="类初始化的实际过程"></a>类初始化的实际过程</h2><p>但是，考虑这样一个例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;Animal.walk()&quot;</span>);<br>	&#125;<br>	Animal()&#123;<br>		System.out.println(<span class="hljs-string">&quot;Animal() before walk()&quot;</span>);<br>		walk();<br>		System.out.println(<span class="hljs-string">&quot;Animal() after walk()&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;Cat.walk(), step = &quot;</span> + step);<br>	&#125;<br>	<br>	Cat(<span class="hljs-type">int</span> step)&#123;<br>		<span class="hljs-built_in">this</span>.step = step;<br>		System.out.println(<span class="hljs-string">&quot;Cat.Cat(), step = &quot;</span> + step);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">500</span>);<br>	<br>&#125;  <br><br></code></pre></td></tr></table></figure>

<p>Animal类的walk方法被设计为在Cat类中被重写，但是Animal的构造器会调用这个walk方法，这导致了对Cat.walk()的调用。<br>上述代码的生成结果是：</p>
<blockquote>
<p>Animal() before walk()<br>Cat.walk(), step &#x3D; 0<br>Animal() after walk()<br>Cat.Cat(), step &#x3D; 500</p>
</blockquote>
<p>我们会发现当Animal的构造器调用walk()方法的时候，step不是默认的初始值100，而是0。<br>因此前面讲的类初始化的顺序并不完整，实际上类的初始化顺序应该是这样的：<br>（1）<strong>在所有事情发生之前先分配空间，将分配给对象的存储空间初始化成二进制的零（或者某些特殊数据类型中与零等价的值）</strong><br>（2）如前所述的调用基类构造器，这个时候在调用cat构造器之前就要调用walk方法，因此此时的step值是0<br>（3）按照声明的顺序调用成员的初始化方法<br>（4）调用类构造器的主体<br>当然，这种错误并不容易发现，因此推荐大家如果可以的话，构造器中尽可能避免调用其他方法，在构造器内唯一能够安全调用的那些方法是基类的final方法（因为他们不会被重写，也就不会有上述的问题）。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
